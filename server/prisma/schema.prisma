// Smart Restaurant System - Database Schema
// Project: Multi-App Restaurant Management System
// Database: PostgreSQL 14+
// ORM: Prisma
// Validated Against: Constitution v1.0.0 - Principle II (Relational Integrity)

generator client {
    provider = "prisma-client-js"
    output   = "../node_modules/.prisma/client"
}

datasource db {
    provider = "postgresql"
}

// ========================================
// ENUMS
// ========================================

enum UserRole {
    SUPER_ADMIN // Can manage all restaurants and admins
    ADMIN // Restaurant owner/manager
    WAITER // Service staff
    KITCHEN_STAFF // Kitchen display system user
    CUSTOMER // Registered customer
    GUEST // Unregistered customer (single session)
}

enum TableStatus {
    AVAILABLE
    OCCUPIED
    RESERVED
}

enum MenuCategory {
    APPETIZER
    MAIN_COURSE
    DESSERT
    BEVERAGE
}

enum OrderStatus {
    PENDING // Order created, awaiting confirmation
    CONFIRMED // Order confirmed by waiter/system
    PREPARING // Kitchen is preparing
    READY // Ready for pickup/serving
    SERVED // Delivered to customer
    PAID // Payment completed
    CANCELLED // Order cancelled
}

enum PaymentStatus {
    UNPAID // No payment initiated
    PENDING // Payment processing
    PAID // Payment successful
    FAILED // Payment failed
}

enum PaymentMethod {
    CASH
    CARD
    E_WALLET
}

enum PaymentTransactionStatus {
    PENDING
    SUCCESS
    FAILED
    REFUNDED
}

enum OrderItemStatus {
    QUEUED // Waiting to be prepared
    COOKING // Currently being prepared
    READY // Completed
}

// ========================================
// MODELS
// ========================================

// User - All system users (guests, waiters, kitchen staff, admins)
model User {
    id           String   @id @default(uuid())
    email        String   @unique
    passwordHash String
    role         UserRole
    name         String?
    phoneNumber  String?
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    // Relationships
    restaurantsOwned Restaurant[] // For ADMIN role
    ordersAsCustomer Order[]      @relation("CustomerOrders")
    ordersAsWaiter   Order[]      @relation("WaiterOrders")

    @@index([email])
    @@map("User")
}

// Restaurant - For future multi-tenant support
model Restaurant {
    id          String   @id @default(uuid())
    name        String
    address     String?
    phoneNumber String?
    adminId     String // Foreign Key to User (ADMIN role)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    // Relationships
    admin      User       @relation(fields: [adminId], references: [id], onDelete: Restrict)
    tables     Table[]
    menuItems  MenuItem[]
    categories Category[]
    modifiers  Modifier[]

    @@index([adminId])
    @@map("Restaurant")
}

// Table - Physical restaurant tables
model Table {
    id               String      @id @default(uuid())
    tableNumber      Int         @unique
    capacity         Int // Validated in application: 1-20
    location         String? // e.g., "Main Floor", "Patio", "Private Room"
    description      String?     @db.Text
    status           TableStatus @default(AVAILABLE)
    qrCode           String?     @db.Text // Base64 QR image (stored as TEXT, no unique constraint due to size)
    qrToken          String?     @unique @db.VarChar(500) // JWT token for table access
    qrTokenCreatedAt DateTime? // When QR token was generated
    restaurantId     String? // Optional: for multi-tenant
    createdAt        DateTime    @default(now())
    updatedAt        DateTime    @updatedAt

    // Relationships
    restaurant Restaurant? @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
    orders     Order[]

    @@index([tableNumber])
    @@index([status])
    @@index([location])
    @@index([restaurantId])
    @@map("Table")
}

// Category - Menu item categories (alternative organization)
model Category {
    id           String   @id @default(uuid())
    name         String
    description  String?
    displayOrder Int      @default(0)
    isActive     Boolean  @default(true)
    restaurantId String?
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    // Relationships
    restaurant Restaurant? @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
    menuItems  MenuItem[]

    @@index([restaurantId])
    @@map("Category")
}

// MenuItem - Items available on the menu
model MenuItem {
    id                   String       @id @default(uuid())
    name                 String
    description          String?
    category             MenuCategory
    price                Decimal      @db.Decimal(10, 2)
    imageUrl             String?
    isAvailable          Boolean      @default(true)
    isSoldOut            Boolean      @default(false)
    isChefRecommendation Boolean      @default(false)
    preparationTime      Int? // in minutes
    categoryId           String? // Optional: reference to Category model
    restaurantId         String?
    createdAt            DateTime     @default(now())
    updatedAt            DateTime     @updatedAt

    // Relationships
    categoryModel Category?   @relation(fields: [categoryId], references: [id], onDelete: SetNull)
    restaurant    Restaurant? @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
    orderItems    OrderItem[]
    modifiers     Modifier[]

    @@index([category, isAvailable])
    @@index([isAvailable])
    @@index([categoryId])
    @@index([restaurantId])
    @@map("MenuItem")
}

// Modifier - Menu item customizations (e.g., "Extra Cheese", "No Onions")
model Modifier {
    id           String   @id @default(uuid())
    name         String
    price        Decimal  @default(0) @db.Decimal(10, 2)
    groupName    String? // e.g., "Toppings", "Side Options"
    menuItemId   String
    restaurantId String?
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    // Relationships
    menuItem   MenuItem    @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
    restaurant Restaurant? @relation(fields: [restaurantId], references: [id], onDelete: Cascade)

    @@index([menuItemId])
    @@index([restaurantId])
    @@map("Modifier")
}

// Order - Customer orders
model Order {
    id              String        @id @default(uuid())
    orderNumber     Int           @unique @default(autoincrement())
    tableId         String
    userId          String? // Nullable for guest orders
    guestName       String? // For guest orders
    guestContact    String? // For guest orders
    waiterId        String?
    status          OrderStatus   @default(PENDING)
    totalAmount     Decimal       @default(0) @db.Decimal(10, 2)
    paymentStatus   PaymentStatus @default(UNPAID)
    paymentIntentId String? // Stripe payment intent ID
    notes           String?
    createdAt       DateTime      @default(now())
    updatedAt       DateTime      @updatedAt
    paidAt          DateTime?

    // Relationships
    table      Table       @relation(fields: [tableId], references: [id], onDelete: Restrict)
    customer   User?       @relation("CustomerOrders", fields: [userId], references: [id], onDelete: SetNull)
    waiter     User?       @relation("WaiterOrders", fields: [waiterId], references: [id], onDelete: SetNull)
    orderItems OrderItem[]
    payment    Payment?

    @@index([orderNumber])
    @@index([tableId, status])
    @@index([status])
    @@index([createdAt])
    @@index([userId])
    @@index([waiterId])
    @@map("Order")
}

// OrderItem - Individual items within an order
model OrderItem {
    id                  String          @id @default(uuid())
    orderId             String
    menuItemId          String
    quantity            Int
    unitPrice           Decimal         @db.Decimal(10, 2)
    subtotal            Decimal         @db.Decimal(10, 2)
    itemStatus          OrderItemStatus @default(QUEUED)
    specialInstructions String?
    createdAt           DateTime        @default(now())

    // Relationships
    order    Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
    menuItem MenuItem @relation(fields: [menuItemId], references: [id], onDelete: Restrict)

    @@index([orderId])
    @@index([menuItemId])
    @@map("OrderItem")
}

// Payment - Payment transactions
model Payment {
    id                    String                   @id @default(uuid())
    orderId               String                   @unique
    amount                Decimal                  @db.Decimal(10, 2)
    method                PaymentMethod
    status                PaymentTransactionStatus @default(PENDING)
    stripePaymentIntentId String?                  @unique
    transactionId         String?
    metadata              Json?
    createdAt             DateTime                 @default(now())
    completedAt           DateTime?

    // Relationships
    order Order @relation(fields: [orderId], references: [id], onDelete: Restrict)

    @@index([orderId])
    @@index([stripePaymentIntentId])
    @@index([status])
    @@map("Payment")
}
